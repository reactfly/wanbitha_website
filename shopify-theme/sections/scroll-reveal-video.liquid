{% comment %}
  Section: Scroll Reveal Video (Mystery Effect)
  Description: A video that reveals itself mysteriously as you scroll, with blend modes and scroll-linked animations.
{% endcomment %}

<div
  class="scroll-mystery-section"
  data-section-id="{{ section.id }}"
  data-section-type="scroll-mystery"
  style="--min-height: {{ section.settings.scroll_height }}vh; --overlay-opacity: {{ section.settings.overlay_opacity | times: 1.0 | divided_by: 100 }};"
  data-parallax="{{ section.settings.parallax_speed }}"
  data-blur="{{ section.settings.blur_intensity }}"
  data-scale="{{ section.settings.scale_intensity }}"
>
  <div class="scroll-mystery__sticky-container">
    <div class="scroll-mystery__video-wrapper">
      {%- if section.settings.video_file != blank -%}
        {{
          section.settings.video_file
          | video_tag:
            image_size: '2000x',
            autoplay: true,
            loop: true,
            muted: true,
            controls: false,
            class: 'scroll-mystery__video',
            preload: 'auto',
            playsinline: true
        }}
      {%- elsif section.settings.video_url != blank -%}
        <!-- Fallback for external URL if needed, though video_tag is preferred -->
        <video
          class="scroll-mystery__video"
          src="{{ section.settings.video_url }}"
          muted
          loop
          playsinline
          preload="auto"
          aria-hidden="true"
        ></video>
      {%- endif -%}

      {%- if section.settings.poster != blank -%}
        <div
          class="scroll-mystery__poster"
          style="background-image: url('{{ section.settings.poster | image_url: width: 2000 }}');"
        ></div>
      {%- endif -%}

      <div class="scroll-mystery__video-overlay"></div>
    </div>

    <div class="scroll-mystery__content container">
      <div class="scroll-mystery__text-wrapper">
        {%- if section.settings.heading != blank -%}
          <h2 class="heading-display heading-display--xl scroll-mystery__heading" data-reveal-text>
            {{ section.settings.heading }}
          </h2>
        {%- endif -%}

        {%- if section.settings.text != blank -%}
          <div class="scroll-mystery__body text-editorial" data-reveal-text>
            {{ section.settings.text }}
          </div>
        {%- endif -%}
      </div>
    </div>

    <div class="scroll-mystery__indicators" aria-hidden="true">
      <div class="scroll-mystery__dot active"></div>
      <div class="scroll-mystery__dot"></div>
      <div class="scroll-mystery__dot"></div>
    </div>

    <button class="scroll-mystery__scroll-hint" aria-label="Scroll to explore">
      <span class="scroll-mystery__arrow"></span>
    </button>
  </div>
</div>

<style>
  .scroll-mystery-section {
    position: relative;
    height: var(--min-height, 300vh);
    background-color: var(--color-bg-primary);
    z-index: 10;
  }

  .scroll-mystery__sticky-container {
    position: sticky;
    top: 0;
    height: 100vh;
    width: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .scroll-mystery__video-wrapper {
    position: absolute;
    inset: 0;
    z-index: 1;
    pointer-events: none;
    background-color: #000;
  }

  .scroll-mystery__video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    filter: blur(20px) grayscale(100%);
    transform: scale(1.2);
    -webkit-mask-image: radial-gradient(circle at center, black 0%, transparent 0%);
    mask-image: radial-gradient(circle at center, black 0%, transparent 0%);
    will-change: opacity, filter, transform, mask-image;
    mix-blend-mode: {{ section.settings.blend_mode }};
  }

  .scroll-mystery__video-overlay {
    position: absolute;
    inset: 0;
    background: radial-gradient(circle, transparent 40%, var(--color-bg-primary) 120%);
    z-index: 2;
    opacity: var(--overlay-opacity, 0.8);
  }

  .scroll-mystery__poster {
    position: absolute;
    inset: 0;
    background-size: cover;
    background-position: center;
    opacity: 0.2;
    z-index: 0;
    transition: opacity 0.5s ease;
    mix-blend-mode: luminosity;
  }

  .scroll-mystery__content {
    position: relative;
    z-index: 3;
    text-align: center;
    opacity: 0;
    transform: translateY(40px);
    transition: opacity 0.8s ease, transform 0.8s ease;
  }

  .scroll-mystery__heading {
    margin-bottom: 24px;
    color: var(--text-primary);
    text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  }

  .scroll-mystery__body {
    max-width: 600px;
    margin: 0 auto;
    font-size: 1.25rem;
    color: var(--text-secondary);
  }

  .scroll-mystery__indicators {
    position: absolute;
    right: 32px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 12px;
    z-index: 4;
  }

  .scroll-mystery__dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }

  .scroll-mystery__dot.active {
    background: var(--color-rose-hot);
    transform: scale(1.5);
    box-shadow: 0 0 10px var(--color-rose-hot);
  }

  .scroll-mystery__scroll-hint {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    z-index: 4;
    opacity: 0;
    transition: opacity 0.5s ease;
    animation: bounce 2s infinite;
  }

  .scroll-mystery-section.is-intro .scroll-mystery__scroll-hint {
    opacity: 1;
  }

  @keyframes bounce {
    0%, 20%, 50%, 80%, 100% {transform: translateX(-50%) translateY(0);}
    40% {transform: translateX(-50%) translateY(-10px);}
    60% {transform: translateX(-50%) translateY(-5px);}
  }

  .scroll-mystery__arrow {
    display: block;
    width: 20px;
    height: 20px;
    border-right: 2px solid white;
    border-bottom: 2px solid white;
    transform: rotate(45deg);
  }

  @media (max-width: 768px) {
    .scroll-mystery__indicators { right: 16px; }
    .scroll-mystery__heading { font-size: 2.5rem; }
  }
</style>

<script>
  (function () {
    // Utilities
    const lerp = (start, end, factor) => start + (end - start) * factor;
    const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

    function getMaskString(size) {
      const s = Math.max(0, size);
      // Soften the edge slightly for a more premium feel
      return `radial-gradient(circle at center, black ${s}%, transparent ${s + 25}%)`;
    }

    const initSection = (section) => {
      const video = section.querySelector('.scroll-mystery__video');
      const poster = section.querySelector('.scroll-mystery__poster');
      const dots = section.querySelectorAll('.scroll-mystery__dot');
      const content = section.querySelector('.scroll-mystery__content');
      const title = section.querySelector('.scroll-mystery__heading');
      const body = section.querySelector('.scroll-mystery__body');

      // Config
      const config = {
        parallaxSpeed: parseFloat(section.dataset.parallax || 0.5),
        maxBlur: parseInt(section.dataset.blur || 20),
        maxScale: parseFloat(section.dataset.scale || 1.2),
        lerpFactor: 0.1, // Adjust for "weight" (lower = smoother/slower)
      };

      // State
      let targetProgress = 0;
      let currentProgress = 0;
      let rafId = null;
      let isVisible = false;

      // Initialize Text Stagger
      if (title) title.style.transitionDelay = '0ms';
      if (body) body.style.transitionDelay = '150ms';

      const updateState = () => {
        const rect = section.getBoundingClientRect();
        const winHeight = window.innerHeight;
        const totalDist = section.offsetHeight - winHeight;

        // Calculate progress based on scroll position
        // 0 when section top hits viewport top (sticky starts)
        // 1 when section bottom hits viewport bottom (sticky ends)
        let rawProgress = (rect.top * -1) / diffHeight(section, winHeight);

        // Handle cases where content is smaller than viewport (shouldn't happen with min-height)
        if (!isFinite(rawProgress)) rawProgress = 0;

        targetProgress = clamp(rawProgress, 0, 1);

        // If we are significantly far from target, request frame
        if (Math.abs(targetProgress - currentProgress) > 0.001) {
          if (!rafId) rafId = requestAnimationFrame(render);
        }
      };

      // Helper to calculate scrollable distance correctly
      const diffHeight = (el, winH) => Math.max(1, el.offsetHeight - winH);

      const render = () => {
        // Smooth interpolation
        currentProgress = lerp(currentProgress, targetProgress, config.lerpFactor);

        // Snap to target if very close to stop CPU usage
        if (Math.abs(targetProgress - currentProgress) < 0.001) {
          currentProgress = targetProgress;
          rafId = null;
        } else {
          rafId = requestAnimationFrame(render);
        }

        applyVisuals(currentProgress);
      };

      const applyVisuals = (progress) => {
        // Video Reveal Phase
        // We want the video to be fully revealed by 60% of scroll?
        // Let's stretch it. 1.0 means fully scrolled.

        const revealPhase = clamp(progress * 1.6, 0, 1);

        if (video) {
          // Opacity
          video.style.opacity = clamp(revealPhase * 1.8, 0, 1);

          // Blur & Grayscale
          const currentBlur = config.maxBlur - revealPhase * config.maxBlur;
          const currentGray = 100 - revealPhase * 100;
          video.style.filter = `blur(${currentBlur.toFixed(2)}px) grayscale(${currentGray.toFixed(0)}%)`;

          // Scale & Parallax
          const currentScale = config.maxScale - revealPhase * (config.maxScale - 1.0);
          const parallaxY = progress * 100 * config.parallaxSpeed;
          video.style.transform = `scale(${currentScale.toFixed(3)}) translateY(${parallaxY.toFixed(1)}px)`;

          // Mask
          const maskSize = revealPhase * 150;
          const maskVal = getMaskString(maskSize);
          video.style.webkitMaskImage = maskVal;
          video.style.maskImage = maskVal;
        }

        if (poster) {
          // Fade out poster faster
          poster.style.opacity = clamp(0.2 - revealPhase * 0.4, 0, 0.2);
        }

        // Content Reveal Phase
        // Starts appearing after 30%
        if (content) {
          if (progress > 0.3) {
            const contentProgress = clamp((progress - 0.3) * 2.5, 0, 1); // faster reveal
            content.style.opacity = contentProgress;
            content.style.transform = `translateY(${40 - contentProgress * 40}px)`;

            // Pointer events
            content.style.pointerEvents = contentProgress > 0.8 ? 'auto' : 'none';
          } else {
            content.style.opacity = 0;
            content.style.transform = `translateY(40px)`;
            content.style.pointerEvents = 'none';
          }
        }

        // Dots & UI
        if (progress < 0.33) updateDots(dots, 0);
        else if (progress < 0.66) updateDots(dots, 1);
        else updateDots(dots, 2);

        if (progress < 0.1) section.classList.add('is-intro');
        else section.classList.remove('is-intro');
      };

      const onScroll = () => {
        updateState();
      };

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              isVisible = true;
              window.addEventListener('scroll', onScroll, { passive: true });
              if (video && video.paused) video.play().catch(() => {});
              // Kickstart
              updateState();
            } else {
              isVisible = false;
              window.removeEventListener('scroll', onScroll);
              if (video && !video.paused) video.pause();
              if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
              }
            }
          });
        },
        { rootMargin: '0px' }
      );

      observer.observe(section);

      // Initial render
      updateState();
      render();
    };

    const updateDots = (dots, index) => {
      // Optimized: only update if needed class check is handled by browser efficiently usually,
      // but we can add a check if strict performance is needed.
      dots.forEach((dot, i) => {
        if (i === index) dot.classList.add('active');
        else dot.classList.remove('active');
      });
    };

    // Initialization logic
    document.querySelectorAll('[data-section-type="scroll-mystery"]').forEach(initSection);
    document.addEventListener('shopify:section:load', (e) => {
      if (e.target.dataset.sectionType === 'scroll-mystery') initSection(e.target);
    });
  })();
</script>

{% schema %}
{
  "name": "Scroll Video (Mystery)",
  "settings": [
    {
      "type": "video",
      "id": "video_file",
      "label": "Video File (Shopify Hosted)",
      "info": "Upload a video directly to Shopify Files. Recommended for best performance."
    },
    {
      "type": "text",
      "id": "video_url",
      "label": "Video URL (External)",
      "info": "Optional. Fallback to external MP4 URL if no file is uploaded above."
    },
    {
      "type": "image_picker",
      "id": "poster",
      "label": "Poster Image",
      "info": "Shown while video loads or as a fallback."
    },
    {
      "type": "header",
      "content": "Layout & Animation"
    },
    {
      "type": "range",
      "id": "scroll_height",
      "min": 150,
      "max": 500,
      "step": 50,
      "unit": "vh",
      "label": "Scroll Distance Height",
      "default": 300
    },
    {
      "type": "range",
      "id": "parallax_speed",
      "min": 0,
      "max": 2,
      "step": 0.1,
      "label": "Parallax Intensity",
      "default": 0.5
    },
    {
      "type": "range",
      "id": "scale_intensity",
      "min": 1,
      "max": 2,
      "step": 0.1,
      "label": "Initial Zoom Scale",
      "default": 1.2
    },
    {
      "type": "range",
      "id": "blur_intensity",
      "min": 0,
      "max": 50,
      "step": 5,
      "unit": "px",
      "label": "Initial Blur Amount",
      "default": 20
    },
    {
      "type": "header",
      "content": "Styling"
    },
    {
      "type": "text",
      "id": "heading",
      "label": "Heading",
      "default": "Descubra o Invisível"
    },
    {
      "type": "textarea",
      "id": "text",
      "label": "Text",
      "default": "Role para revelar os mistérios ocultos."
    },
    {
      "type": "range",
      "id": "overlay_opacity",
      "min": 0,
      "max": 100,
      "step": 5,
      "unit": "%",
      "label": "Overlay Opacity",
      "default": 80
    },
    {
      "type": "select",
      "id": "blend_mode",
      "label": "Mystery Blend Mode",
      "options": [
        { "value": "normal", "label": "Normal" },
        { "value": "multiply", "label": "Multiply (Darker)" },
        { "value": "screen", "label": "Screen (Lighter)" },
        { "value": "overlay", "label": "Overlay (Contrast)" },
        { "value": "difference", "label": "Difference (Psychedelic)" }
      ],
      "default": "screen"
    }
  ],
  "presets": [
    {
      "name": "Scroll Reveal Video"
    }
  ]
}
{% endschema %}
