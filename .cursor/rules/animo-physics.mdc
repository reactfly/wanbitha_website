---
description: Manim Physics Guide for Animo
globs:
alwaysApply: true
---

# Creating Physical Animations with Manim-Physics

You are working with **Manim-Physics**, a powerful extension library for Manim that enables you to create realistic physical simulations and visualizations. This guide explains how to use manim-physics to create animations involving rigid body dynamics, electromagnetic fields, pendulums, waves, and other physical phenomena.

## What is Manim-Physics?

Manim-Physics is a physics simulation library built on top of Manim that allows you to:

- **Simulate rigid body dynamics** with gravity, collisions, and forces
- **Visualize electromagnetic fields** (electric fields, magnetic fields)
- **Create pendulum simulations** with customizable lengths and behaviors
- **Render wave phenomena** including standing waves and interference patterns
- **Animate atomic and molecular interactions** with realistic forces
- **Build complex physical systems** with proper physics interactions

## Core Components

### 1. SpaceScene - The Foundation for Physics Simulations

`SpaceScene` is the base class for creating physics simulations with manim-physics. It provides a physics engine and methods for manipulating rigid bodies.

#### Basic Structure

```python
from manim import *
from manim_physics import *

class MyPhysicsScene(SpaceScene):
    def construct(self):
        # Your physics animation here
        self.wait(5)
```

#### Key Methods

**`make_rigid_body(mobject)`**
Converts any mobject (shape) into a rigid body that responds to physics:

```python
# Create a shape
circle = Circle(radius=0.5, color=BLUE)
circle.move_to(UP * 2)

# Make it a rigid body (falls due to gravity)
self.make_rigid_body(circle)

self.wait(3)  # Watch it fall
```

**`make_static_body(mobject)`**
Creates immovable objects like walls and floors:

```python
ground = Line(LEFT * 4, RIGHT * 4, stroke_width=4)
self.make_static_body(ground)
```

**`space.gravity`**
Control the gravitational acceleration:

```python
# Default is roughly 9.8 equivalent
# Reduce for slower, floating effect
self.space.gravity = (0, -2, 0)

# Increase for faster falling
self.space.gravity = (0, -20, 0)
```

### 2. Working with Rigid Bodies

Rigid bodies can be manipulated, animated, and will interact with physics forces.

#### Example: Multiple Objects Falling

```python
from manim import *
from manim_physics import *

class FallingObjectsDemo(SpaceScene):
    def construct(self):
        # Create various shapes
        circle = Circle(radius=0.4, color=RED)
        circle.move_to(LEFT * 2 + UP * 3)

        square = Square(side_length=0.6, color=BLUE)
        square.move_to(UP * 3)

        triangle = Triangle(color=GREEN)
        triangle.move_to(RIGHT * 2 + UP * 3)

        # Create a floor
        ground = Line(LEFT * 4, RIGHT * 4, stroke_width=4, color=WHITE)
        ground.move_to(DOWN * 3)

        # Add everything to the scene
        self.add(circle, square, triangle, ground)

        # Make shapes rigid bodies, floor static
        self.make_rigid_body(circle, square, triangle)
        self.make_static_body(ground)

        # Watch the physics happen!
        self.wait(5)
```

#### Collision Detection

Objects automatically collide when made into rigid bodies. The physics engine handles:
- Elastic collisions (bouncing)
- Energy loss (realistic behavior)
- Multiple simultaneous collisions
- Rotational physics

### 3. Pendulum Simulations

The `Pendulum` class creates realistic pendulum systems that swing under gravity.

#### Simple Pendulum

```python
from manim import *
from manim_physics import *

class PendulumDemo(SpaceScene):
    def construct(self):
        # Create a pendulum with length 3
        pendulum = Pendulum(length=3, color=BLUE)

        self.add(pendulum)

        # Make it a rigid body and start swinging
        self.make_rigid_body(pendulum)
        pendulum.start_swinging()

        self.wait(10)
```

#### Multiple Pendulums with Different Periods

```python
class MultiplePendulums(SpaceScene):
    def construct(self):
        # Create pendulums with different lengths
        lengths = np.linspace(1, 5, 7)
        pendulums = VGroup(*[Pendulum(length=L) for L in lengths])

        # Color them beautifully
        colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#FFA07A",
                  "#98D8C8", "#F7DC6F", "#BB8FCE"]
        for p, color in zip(pendulums, colors):
            for bob in p.bobs:
                bob.set_color(color)

        self.add(pendulums)

        # Make them rigid bodies and swing
        for p in pendulums:
            self.make_rigid_body(*p.bobs)
            p.start_swinging()

        # Optional: trace the paths
        for i, p in enumerate(pendulums):
            self.add(
                TracedPath(
                    p.bobs[-1].get_center,
                    stroke_color=colors[i],
                    stroke_width=2,
                    stroke_opacity=0.6
                )
            )

        self.wait(15)
```

### 4. Electromagnetic Fields

Visualize electric and magnetic fields using manim-physics components.

#### Electric Fields

```python
from manim import *
from manim_physics import Charge, ElectricField

class ElectricFieldDemo(Scene):
    def construct(self):
        # Create charges
        negative_charge = Charge(-1, LEFT + DOWN)
        positive_charge = Charge(2, RIGHT + DOWN)
        negative_top = Charge(-1, UP)

        charges = VGroup(negative_charge, positive_charge, negative_top)

        # Create and visualize the electric field
        field = ElectricField(*charges)

        # Show charges first
        self.play(FadeIn(charges))
        self.wait(0.5)

        # Draw the field
        self.play(Create(field), run_time=2)
        self.wait(2)

        # Move charges and update field dynamically
        self.play(
            negative_charge.animate.move_to(RIGHT * 0.5 + DOWN * 2),
            FadeOut(field),
            run_time=2
        )

        # Create new field at new positions
        field = ElectricField(*charges)
        self.play(Create(field), run_time=2)
        self.wait(3)
```

**Key Electric Field Features:**
- Visualizes field lines and intensity with vectors
- Automatically updates when charges move
- Color intensity represents field strength
- Works with arbitrary charge configurations

#### Magnetic Fields

```python
from manim import *
from manim_physics import Wire, MagneticField

class MagneticFieldDemo(ThreeDScene):
    def construct(self):
        # Create a wire in a circular coil
        wire = Wire(Circle(2.5).rotate(PI / 2, UP))
        wire.set_color("#FFD700")
        wire.set_stroke(width=8)

        # Create the magnetic field visualization
        mag_field = MagneticField(
            wire,
            x_range=[-5, 5],
            y_range=[-5, 5],
            colors=["#FF1744", "#FF6B35", "#FF9500", "#F72585", "#7209B7"]
        )

        # Set up 3D camera
        self.set_camera_orientation(phi=PI / 3, theta=PI / 4)

        self.add(wire, mag_field)

        # Rotate camera for dynamic effect
        self.begin_ambient_camera_rotation(rate=0.3)
        self.wait(15)
        self.stop_ambient_camera_rotation()
```

### 5. Wave Phenomena

Create and animate standing waves and wave interference patterns.

#### Standing Waves

```python
from manim import *
from manim_physics import StandingWave

class StandingWaveDemo(Scene):
    def construct(self):
        # Create standing waves with different harmonics
        wave1 = StandingWave(1, color="#FF0000", stroke_width=6)  # Fundamental
        wave2 = StandingWave(2, color="#FFA500", stroke_width=6)  # 2nd harmonic
        wave3 = StandingWave(3, color="#00FF00", stroke_width=6)  # 3rd harmonic

        waves = VGroup(wave1, wave2, wave3)
        waves.arrange(DOWN, buff=1.5)

        self.add(waves)

        # Start all waves oscillating
        for wave in waves:
            wave.start_wave()

        # Show for 15 seconds
        self.wait(15)
```

**Standing Wave Features:**
- Different harmonics (n=1, 2, 3, ...)
- Customizable colors and stroke width
- Automatic oscillation with `start_wave()`
- Perfect for physics education content

### 6. Advanced: Custom Physics with Updaters

For complex physical systems not covered by built-in classes, use updaters to implement custom physics.

#### Custom Gravity and Collision System

```python
class CustomPhysicsDemo(Scene):
    def construct(self):
        # Create objects
        objects = VGroup()

        planet1 = Circle(radius=0.4, color=RED)
        planet1.move_to(LEFT * 3 + UP * 1)
        planet1.mass = 5.0
        objects.add(planet1)

        planet2 = Circle(radius=0.3, color=BLUE)
        planet2.move_to(RIGHT * 3 + UP * 1)
        planet2.mass = 3.0
        objects.add(planet2)

        # Set initial velocities
        planet1.velocity = np.array([2.0, -1.0, 0.0])
        planet2.velocity = np.array([-2.0, -1.0, 0.0])

        self.add(objects)

        # Custom physics updater
        def update_physics(obj, dt):
            # Apply gravity
            gravity = np.array([0.0, -2.0, 0.0])
            obj.velocity += gravity * dt

            # Update position
            obj.shift(obj.velocity * dt)

            # Boundary collisions (bounce off edges)
            if obj.get_center()[0] < -6 or obj.get_center()[0] > 6:
                obj.velocity[0] *= -0.8
            if obj.get_center()[1] < -3 or obj.get_center()[1] > 3:
                obj.velocity[1] *= -0.8

        # Add updaters to all objects
        for obj in objects:
            obj.add_updater(update_physics)

        # Run simulation
        self.wait(8)

        # Clean up
        for obj in objects:
            obj.clear_updaters()
```

**Custom Physics Pattern:**
1. Attach velocity vectors to mobjects as attributes
2. Create an updater function that modifies position and velocity
3. Use `add_updater()` to apply physics each frame
4. Handle collisions in the updater or separately
5. Clean up with `clear_updaters()` when done

### 7. Atomic and Molecular Simulations

Combine rigid bodies with visual effects to simulate chemistry and atomic physics.

#### Water Molecule Formation

```python
from manim import *
from manim_physics import *

class AtomicSimulation(SpaceScene):
    def construct(self):
        # Create atoms
        hydrogen1 = Circle(radius=0.15, color=WHITE)
        hydrogen1.move_to(LEFT * 3 + UP * 1)

        hydrogen2 = Circle(radius=0.15, color=WHITE)
        hydrogen2.move_to(LEFT * 3 + DOWN * 1)

        oxygen = Circle(radius=0.2, color=RED)
        oxygen.move_to(RIGHT * 3)

        # Labels
        h1_label = Text("H", font_size=16).move_to(hydrogen1.get_center())
        h2_label = Text("H", font_size=16).move_to(hydrogen2.get_center())
        o_label = Text("O", font_size=16).move_to(oxygen.get_center())

        atoms = VGroup(hydrogen1, hydrogen2, oxygen)
        labels = VGroup(h1_label, h2_label, o_label)

        self.add(atoms, labels)

        # Apply physics
        self.make_rigid_body(hydrogen1, hydrogen2, oxygen)
        self.space.gravity = (0, -50, 0)  # Molecular gravity

        self.wait(3)

        # Show chemical bonds
        bond1 = Line(hydrogen1.get_center(), oxygen.get_center(),
                     color=YELLOW, stroke_width=4)
        bond2 = Line(hydrogen2.get_center(), oxygen.get_center(),
                     color=YELLOW, stroke_width=4)

        self.play(Create(bond1), Create(bond2))

        # Energy burst visualization
        energy_particles = VGroup()
        for _ in range(20):
            particle = Dot(radius=0.03, color=random_color())
            particle.move_to(oxygen.get_center())
            energy_particles.add(particle)

        # Animate particles bursting outward
        self.play(*[
            particle.animate.shift(
                np.random.uniform(-1, 1) * RIGHT + np.random.uniform(-1, 1) * UP
            ).fade(1)
            for particle in energy_particles
        ], run_time=1.5)

        self.wait(2)
```

## Best Practices

### 1. Scene Configuration
- Use `SpaceScene` for physics simulations requiring gravity
- Use `ThreeDScene` for 3D visualizations (magnetic fields, 3D objects)
- Use regular `Scene` for electromagnetic fields without gravity

### 2. Performance Optimization
- Limit the number of rigid bodies (complex collisions are expensive)
- Use traced paths sparingly (store fewer points)
- Adjust simulation timestep in advanced cases
- Group related objects with `VGroup()`

### 3. Visual Clarity
- Use distinct colors for different objects or forces
- Add labels for scientific accuracy
- Include titles and explanations
- Use transparency to show overlapping fields
- Adjust stroke width for visibility (especially for fields)

### 4. Physics Accuracy
- Set realistic mass values for collisions to work properly
- Use appropriate gravity values for your scale
- Include restitution coefficients for bouncy/elastic collisions
- Test collision detection with simple shapes first

### 5. Educational Value
- Combine physics with clear annotations
- Show before/after states
- Use color to distinguish different states or properties
- Include mathematical labels where relevant
- Use slow-motion for complex interactions

## Common Physics Patterns

### Pattern: Falling Objects with Collision
```python
# Create container walls
walls = VGroup(
    Line([-3, -2, 0], [-3, 3, 0]),  # Left wall
    Line([3, -2, 0], [3, 3, 0]),    # Right wall
    Line([-3, -2, 0], [3, -2, 0])   # Floor
)
self.make_static_body(walls)

# Create falling objects
objects = VGroup(Circle(...), Square(...), Triangle(...))
self.make_rigid_body(*objects)

self.wait(5)  # Watch physics happen
```

### Pattern: Dynamic Field Updates
```python
# Create charges
charges = VGroup(charge1, charge2, charge3)
self.play(FadeIn(charges))

# Initial field
field = ElectricField(*charges)
self.play(Create(field))
self.wait(1)

# Move charges and update field
self.play(FadeOut(field), charge1.animate.move_to(new_position))
field = ElectricField(*charges)  # Recreate with new positions
self.play(Create(field))
```

### Pattern: Traced Motion
```python
# Create traced path
trace = TracedPath(
    mobject.get_center,
    stroke_color=COLOR,
    stroke_width=2,
    stroke_opacity=0.6
)
self.add(trace)

# Mobject will draw its path as it moves
self.make_rigid_body(mobject)
self.wait(10)
```

## Troubleshooting

### Objects not falling
- Ensure you used `make_rigid_body()` not just `make_static_body()`
- Check that gravity is set: `self.space.gravity = (0, -9.8, 0)`
- Verify scene inherits from `SpaceScene`

### Collisions not working
- Both objects must be rigid bodies
- Objects must overlap or touch
- Check mass values are positive
- Ensure objects have radius/size attributes

### Field not displaying
- Verify charges/wire are properly created
- Use `Create()` animation for smooth appearance
- Check color palette is compatible
- Test with simpler configuration first

### Performance issues
- Reduce number of rigid bodies
- Simplify field resolution
- Use lower frame rate for testing
- Disable unnecessary updaters

## Resources

- **Manim Documentation**: Mathematical animation fundamentals
- **Manim-Physics GitHub**: Source code and additional examples
- **Physics Concepts**: Understanding the physics being visualized improves animation quality
- **Color Theory**: Effective visualization through thoughtful color choices
